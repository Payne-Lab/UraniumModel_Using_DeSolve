library("readxl")

#Insert file into working directory
getwd()
setwd("/Users/micpim/Desktop")
Udata <- read_excel("Uranium Data R.xlsx")

#Ignore missing values (NAs), round Age values, and multiply them by a 1 million 
DajAge <- round(Udata$DAJAge[1:27],3) * (1*10^6)
DajUfrac <-Udata$DAJUfrac[1:27]

GuaAge <- round(Udata$GUAAge[1:25],3) * (1*10^6)
GuaUfrac <- Udata$GUAUfrac[1:25]

TasAge <- round(Udata$TASAge[1:28],3)* (1*10^6)
TasUfrac<-Udata$TASUfrac[1:28]

#Read in Fei Feis Data
ZalAge <- round(Udata$ZALAge[1:83],3) * (1*10^6)
ZalUfrac <- Udata$ZALUfrac[1:83]

GarAge <- round(Udata$GARAge[1:34],3)* (1*10^6)
GarUfrac<-Udata$GARUfrac[1:34]

DawAge <- round(Udata$DAWUAge[1:27],3) * (1*10^6)
DawUfrac <-Udata$DAWUfrac[1:27]

KamAge <- round(Udata$KAMAge[1:15],3) * (1*10^6)
KAMUfrac <- Udata$KAMUfrac[1:15]

DaxAge <- round(Udata$DAXAge[1:25],3)* (1*10^6)
DaxUfrac<-Udata$DAXUfrac[1:25]


#Combine all Age and Ufrac values, making sure to append vectors in the same order 
AllAges <- c(DajAge,GuaAge,TasAge)
AllUfrac <- c(DajUfrac,GuaUfrac,TasUfrac)

#Combine all Feis Feis Age and Ufrac data
FeiAge<- c(ZalAge,GarAge,DawAge,KamAge,DaxAge)
FeiUfrac<-c(ZalUfrac,GarUfrac,DawUfrac,KAMUfrac,DaxUfrac )
FeiAge2<- c(FeiAge[1:83],FeiAge[91:159],FeiAge[167:184])
FeiUfrac2<-c(FeiUfrac[1:83],FeiUfrac[91:159],FeiUfrac[167:184])

#Exclude non-boundary time data 
order <- sort(AllAges,decreasing=TRUE)    #Orders data so that we can easily see the non boundary times
ExcludedData<-order[55:80]        #Creates a vector of the nonboundary times
BoundaryAges<-AllAges [! AllAges %in% ExcludedData] #Exludes those times

#Eclude Fei Feis non-boundary data
FeiOrder<- sort(FeiAge, decreasing = TRUE)
exclude_data <- FeiOrder[45:184]
boundary_Ages<-AllAges [! FeiAge %in% exclude_data]

#Remove non boundary UFrac data
RemovedIndex<- match(ExcludedData,AllAges)  #Find the indices for every value of (x,y) x, looking insde y
RemovedData <- AllUfrac[RemovedIndex]        #Uses indices to find values needed to be removed

#Remove non boundary fei fei data
removed_index <- match(exclude_data, FeiAge)
removed_data <- FeiUfrac[removed_index]

#Uses Removed Data to break the data into segements exluding the unwanted data, must be done this way
#To avoid loosing repeating values, taking out the non bounday points by hand instead of using
#The earlier match function

Good <- AllUfrac[1:20]
Good2 <-AllUfrac[28:41]
Good3 <-AllUfrac[53:72]
BoundaryUfrac <- c(Good,Good2,Good3)

##set up data frame to store output of boundary time data from the model
Analysis <- data.frame(matrix(nrow=length(BoundaryUfrac), ncol=7))
names(Analysis) <- c("Min", "Max", "Deviation", "Squared Deviation","Standard Deviation", "AVG Percent Error","Standard Error")

##Set up data frame to store output of entire time data, from the model
EntireAnalysis <- data.frame(matrix(nrow=length(AllUfrac), ncol=7))
names(Analysis) <- c("Min", "Max", "Deviation", "Squared Deviation","Standard Deviation", "AVG Percent Error","Standard Error")

##Set up data frame to store output of entire fei fei time data, from the model
EntireAnalysis <- data.frame(matrix(nrow=length(FeiAge), ncol=7))
names(Analysis) <- c("Min", "Max", "Deviation", "Squared Deviation","Standard Deviation", "AVG Percent Error","Standard Error")


library(deSolve)
## how many iterations ##
nreps <- 200


# length of model run #
duration <-1.8e6 #duration of model run


dt <- 1000 #time step
t.anox.start <- 472000 #time of the onset of perturbation

#set distributions for drawing values for parameters to be estimated
perturbation <- seq(from = 0, to = 0.3, by = 0.002)  #Creates a vector of number from 0 to 0.3, incrementing by 0.002
f.anox.p <- sample(perturbation, size = nreps, replace= TRUE) #anoxic seafloor fraction during perturbation, randomly pics a number from the previously made vector


D.other <- runif(n=nreps, min = -0.05, max = -.02) #fractionation in oxygenated environments
f.anox.b <- runif(n=nreps, min = 0.002, max = 0.0021) #anoxic seafloor fraction before perturbation

D.anox <- runif(n=nreps, min = 0.2, max = 1.2) #fractionation in anoxic environments
dur.p <- runif(n=nreps, min = 0, max = duration-t.anox.start) #duration of perturbation
f.anox.a <- runif(n=nreps, min = 0.002, max = 0.051) #anoxic seafloor fraction after perturbation



#values to be used in setting up the model
t.anox.end <- t.anox.start + dur.p #time of the end of the perturbation
steps <- duration/dt #number of time steps in the model

##set up data frame to store output from the model
U238.ocean <- data.frame(matrix(nrow=steps+1, ncol=nreps)) #matrix of uranium isotope compositions
params <- data.frame(matrix(nrow=nreps, ncol=6))
names(params) <- c("D.other", "D.anox", "f.anox.b", "f.anox.p","dur.p", "f.anox.a")

DU238.ocean <- data.frame(matrix(nrow=54, ncol=nreps))
feifeiU238 <- data.frame(matrix(nrow=170, ncol=nreps))
##set up repetitions of model runs using for loop##

times <- seq(0, duration, dt)

parms <- c(J.riv = 0.4e8, #Lau et al 2016
           k.anox = 1.45772594752187e-4, #Lau et al 2016, calculated
           k.other = 1.73834440079269e-6, #Lau et al 2016, to reach steady state
           deltaU.riv=-0.05) #Lau et al 2016, calculated steady state input to produce d238U ~ -0.165

y <- c(U = 1.96e13, #mol U (Morford and Emerson 1999)
       U238 = -0.165) #Lau et al 2016



#Adjust Model times, and find index of the times at our data points
StratTimes <- 252300000 - times
CompareIndex <- match(BoundaryAges,StratTimes)

#Adjust Model times, and find index of the times at all of fei fei data points
StratTimes <- 252300000 - times
CompareFEIIndex <- match(FeiAge2,StratTimes)


for (i in 1:nreps) {
  print(i)
  
  #uranium cycle model#
  model <- function (time, y, parms) {
    with(as.list(c(y, parms)), {
      f.anox <- f.an(time)
      dU = J.riv - k.anox*f.anox*y[1] - k.other*(1-f.anox)*y[1]
      dU238 = (J.riv*(deltaU.riv - U238) - k.anox*f.anox*y[1]*D.anox[i] - k.other*(1-f.anox)*y[1]*D.other[i])/y[1]
      list(c(dU, dU238))
    })
  } 
  
  forceanox=c(rep(f.anox.b[i],(t.anox.start/dt+1)), rep(f.anox.p[i], #set up anoxia forcing function
                                                        (t.anox.end[i]-t.anox.start)/dt), rep(f.anox.a[i],
                                                                                              (duration-t.anox.end[i])/dt+1))
  anox.event=data.frame(times,forceanox)  #put the anoxia forcing into data frame with time
  f.an = approxfun(x=anox.event[,1],y=anox.event[,2],method="linear",rule=2) #function for calculating f.anox in model
  
  out <- data.frame(ode(y, times, model, parms))
  
  ## need to store output from the model and parameter values in a data frame
  U238.ocean[,i] <- out[,3] #put uranium isotopes from model into data frame
  
  params[i,2] <- D.anox[i] #store value for D.anox, fractionation in anoxic environments
  params[i,4] <- f.anox.p[i] #store value for f.anox.p, perturbation anoxia level
  params[i,5] <- dur.p[i] #store value for dur.p, duration of perturbation
  params[i,6] <- f.anox.a[i] #store value for f.anox.a, after anoxia level
  
 
#put uranium isotopes from model into data fram but only the ones at the data times 
  
  DU238.ocean[,i] <- out$U238[CompareIndex] 
  feifeiU238[,i] <- out$U238[CompareFEIIndex] 
}

#Add noise to the model 
FirstDifKim <- diff(BoundaryUfrac, lag = 1 , differences = 1)

FirstDifFei <- diff(FeiUfrac2, lag = 1, difference = 1)

DU238.ocean <- DU238.ocean + matrix(data = rnorm(n=nrow(DU238.ocean)* ncol(DU238.ocean), mean =0,
                                                sd = sd(FirstDifKim)), nrow = nrow(DU238.ocean), ncol = ncol(DU238.ocean))
feifeiU238 <- feifeiU238 + matrix(data = rnorm(n=nrow(feifeiU238)* ncol(feifeiU238), mean =0,
                                               sd = sd(FirstDifFei)), nrow = nrow(feifeiU238), ncol = ncol(feifeiU238))


#put all model runs with matching times in justModelUfrac dataframe 

DU238.ocean$mod.age <- BoundaryAges
DU238.ocean$realdata <- BoundaryUfrac
ModelAndReal <- DU238.ocean[,1:(nreps)]
ModelAndReal[,(nreps +1)] <- DU238.ocean$realdata

#Same But with fei fei
feifeiU238$mod.age <- FeiAge2
feifeiU238$realdata <- FeiUfrac2
modelAndreal <- feifeiU238[,1:(nreps)]
modelAndreal[,(nreps +1)] <- feifeiU238$realdata


#FEI FEI OR KIM
kim = ModelAndReal

fei = modelAndreal
run = fei

#standardize
mod.ufrac <- as.matrix(run)
m.ufrac <- (mod.ufrac-mean(mod.ufrac))/sd(mod.ufrac)

#plot(DU238.ocean$mod.age~ModelAndReal[,3], las=1)

#TRANSPOSE?
pca <- princomp(t(m.ufrac))

PoV <- pca$sdev^2/sum(pca$sdev^2)

#dev.off()
zz <- as.data.frame(pca$scores[,1:6])

### APPROXIMATE BAYES COMPUTATION ###
ref<-zz[nreps,]
zz$distance <- apply(zz,1,function(x)sqrt(sum((x-ref)^2)))

##combine pca scores and distance with parameter values##
zz.1 <- cbind(params, zz[1:nreps,])

#need to figure out how to color code by parameter values
rbPal <- colorRampPalette(c('yellow', 'black'))

#This adds a column of color values
# based on the y values

zz.1$Col.D.anox <- rbPal(100)[as.numeric(cut(zz.1$D.anox,breaks = 100))]

zz.1$Col.f.anox.p <- rbPal(100)[as.numeric(cut(zz.1$f.anox.p,breaks = 100))]
zz.1$Col.dur.p <- rbPal(100)[as.numeric(cut(zz.1$dur.p,breaks = 100))]
zz.1$Col.distance <- rbPal(100)[as.numeric(cut(zz.1$distance, breaks = 100))]
zz.1$Col.f.anox.a <- rbPal(100)[as.numeric(cut(zz.1$f.anox.a, breaks = 100))]

cols <- list(zz.1$Col..1$D.other, zz.1$Col.D.anox, zz.1$Col.f.anox.b, zz.1$Col.f.anox.p, zz.1$Col.dur.p,zz.1$f.anox.a, zz.1$Col.distance)
titles <- c("D.anox", "f.anox.p", "dur.p", "f.anox.a", "distance")
lim.lower <- c( min(params$D.anox),
               min(params$f.anox.p), min(params$dur.p), min(params$f.anox.a)/100000, min(zz.1$distance))
lim.upper <- c( max(params$D.anox),
               max(params$f.anox.p), max(params$dur.p), max(params$f.anox.a)/100000, max(zz.1$distance))

### get parameter values via approximate bayes computation ###

dist <- min(zz.1$distance)
#Write line, that finds the first percentile , whats the value at first percent
firstPercent <- quantile(zz.1$dist, c(0.010))  
#Subset of ZZ1 where distance is less than first percentile of dist
##zz.2 <- subset(zz.1, distance <= firstPercent & distance < dist + 3
zz.2 <- subset(zz.1, distance <= firstPercent)

d1 <- density(zz.2$f.anox.p)
d3 <- density(zz.2$D.anox)
d5 <- density(zz.2$dur.p)
d6 <- density(zz.2$f.anox.a)

#pdf("abc.parameters.density.pdf", h=8, w=6)
par(mfrow=(c(2,2)), mar=c(3,4,1,1))
plot(d1, main="f.anox.p", las=1, xlim = c(0.01, 1))
polygon(d1, col="red", border="black")

plot(d3, main="D.anox", las=1)
polygon(d3, col="red", border="black")

plot(d5, main="dur.p", las=1, xlim = c(-250000, 2000000))
polygon(d5, col="red", border="black")

plot(d6, main = "f.anox.a", las=1)
polygon(d6, col = "red", border = "black")


### PLOT OUTPUT OF MODEL RUNS THAT ARE INCLUDED AFTER EPSILON FILTER
## WILL SHOW UNCERTAINTY IN THE TIME HISTORY

#StratTimes <- 252500000 - times

par(mfrow=(c(1,1)))
myvars <- rownames(zz.2)
U238.ocean.distance <- U238.ocean[,myvars]
plot(U238.ocean.distance[,1]~ StratTimes, pch=1, cex=0.1, col="white", xlim = rev(c(250750000,252250000)), ylim=c(-1.2,0.2), las=1,
     xlab="model years", ylab="d238U ocean")
for (i in 1:ncol(U238.ocean.distance)) {lines(U238.ocean.distance[,i]~StratTimes, cex=0.1, col=rgb(0, 0, 255, max = 255, alpha = 30))}
points(FeiAge2,FeiUfrac2,col = "green",pch = 19)
points(BoundaryAges,BoundaryUfrac,col = "red",pch = 19)

